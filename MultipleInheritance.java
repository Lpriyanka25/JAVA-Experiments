//Experiment no 06
importjava.util.LinkedList;
public class MultipleInheritance
{
privateLinkedList<E>list;
//Constructor
publicMultipleInheritance(){
list=newLinkedList<>();
}
//StackOperations
@Override
publicvoidpush(Eelement){
list.addFirst(element);
}
@Override
publicEpop(){
if(isEmpty()){
thrownewIllegalStateException("Stackisempty");
}
returnlist.removeFirst();
}
@Override
publicEpeek(){
if(isEmpty()){
thrownewIllegalStateException("Stackisempty");
}
returnlist.getFirst();
}
//QueueOperations
@Override
publicvoidenqueue(Eelement){
list.addLast(element);
}
@Override
publicEdequeue(){
if(isEmpty()){
thrownewIllegalStateException("Queueisempty");
}
returnlist.removeFirst();
}
@Override
publicEfront(){
if(isEmpty()){
thrownewIllegalStateException("Queueisempty");
}
returnlist.getFirst();
}
//CommonOperationsforStackandQueue
@Override
publicbooleanisEmpty(){
returnlist.isEmpty();
}
@Override
publicintsize(){
returnlist.size();
}
//Mainmethodtotestfunctionality
publicstaticvoidmain(String[]args){
MultipleInheritance<Integer>structure=newMultipleInheritance<>();
//StackOperations
structure.push(10);
structure.push(20);
System.out.println("TopofStack:"+structure.peek());//Output:20
structure.pop();
System.out.println("TopofStackafterpop:"+structure.peek());//Outpu
t:10
//QueueOperations
structure.enqueue(30);
structure.enqueue(40);
System.out.println("FrontofQueue:"+structure.front());//Output:10
structure.dequeue();
System.out.println("FrontofQueueafterdequeue:"+structure.front());
//Output:30
}
}
